Agua, tierra, fuego, aire. Hace muchos años, las cuatro naciones vivían en armonía, pero todo cambió cuando la Nación del Fuego atacó. Solo el Avatar, maestro de los cuatro elementos, podía detenerlos. Pero cuando el mundo más lo necesitaba, desapareció. Después de cien años, mi hermano y yo encontramos al nuevo Avatar, un maestro aire llamado Aang. Aunque sus habilidades para controlar el aire eran grandiosas, tenía mucho que aprender antes de poder salvar al mundo. Y yo creo que Aang podrá salvarnos...



declaraciones:

declarar una variable sin inicializar y con tipo concreto:
bender <nombre del maestro> of <Elemento>

Ejemplo:
bender aang of air

declarar una variable inicializada y con tipo concreto: 
bender <nombre del maestro> of <Element> is <exp>

bender aang of air is 100

declarar una variable inicializada y con tipo inferido:
bender <nombre del maestro> is <exp>

bender aang is 100

Para declarar constantes se precede la declaración por eternal. // posible cambio por avatar

eternal <nombre del maestro> of <element> is <exp>

Asignacion:

``` is ```

katara is 5

Referencias:

bender <nombre> is reincarnation of <nombre>
bender korra is reincarnation of aang.

Apuntadores: 

se usa "art"

bender katara of water art is 42.0

null:

an apprentice

ej: bender soka of water art is an apprentice

new:

born as <elem> member

ej: bender soka of water art is born as water member 

// como seria el new para structs y uniones

delete:

<nombre> has died

Tipos de Datos:

Enteros: air

Float: water

Booleano : fire 
   true: lightning master
   false: fire master

ej: bender azula of fire is lightning master

Char :  earth

String: metal

Arreglo: 
bender <name> of <element> nation since <size> years

bender toph of earth nation since 42 years

para inicializar:
master of <name0>, ..., <namek>

bender toph of earth nation since 42 years is master of aang, aang_jr, aang_jr_jr

indexacion:
disciple <indice> of toph

Struct:

element <name> is compound by <name> art of <elem_name>, ...

element lava is compound by super_fire art of fire, bedrock art of earth.


init struct: learning <element name> control using <args>, ...
bender aang is learning mud control using 1, 2.0 

acceso a struct: using <name>'s <name> art

bender aang is using zuko's super_fire art.

Union:

energy <name> allows <elem_tag> technique of <elem_type> bending, ...

energy nature allows wind_kick technique of air bending, rock_smash technique of earth bending

init union:
learning <union_name>'s <elem_tag> technique from <expr1>

bender luis is learning nature's wind_kick technique from aang

acceder a la union:
using <var_name>'s <elem_tag> technique
bender luis is using aang's wind_kick technique.

consultar union:
   trying <var_name>'s <elem_tag> technique
   bender luis is trying aang's wind_kick technique.

Secuenciacion:
   .

bloque de instrucciones:
   inicia con .-, termina con -.

operador unitario:
   ~

funciones:
   book <book_name> of <type_name> about <type_name> bender <name>, ... : <expr>
   book desert_travel of earth with air bender aang, earth bender toph: 
   .-

   -.

proc:
   travel <travel_name> made by <type_name> bender <name>, ... : <expr>
   travel sea_odyssey made by air bender aang, water bender katara : 
   .-
   -.

llamadas a funciones 
   in <f_name> book with <expr1>, <expr2>, <id> is <expr> "..."
   bender luis is in sea_odyssey book with katara, aang and toph.

llamadas a proc igual que en funciones sin el is
   <f_name> with <expr1>, <expr2>, <id> is <expr> "..."
   dessert_travel with aang, zoka, katara.
   
aritmética bool:
   <expr> && <expr> = <expr> and <expr>
   <expr> || <expr> = <expr> or <expr>
   !<expr> = not <expr>

aritmética 
   <expr> + <expr> = <expr> and then <expr>
   <expr> - <expr> = <expr> but <expr>
   <expr> * <expr> = <expr> and thus <expr>
   <expr> \ <expr> = <expr> besides <expr>
   <expr> % <expr> = <expr> left <expr>

   parentesis normales

comparaciones:
   <expr> < <expr> = <expr> is less than <expr>
   <expr> <= <expr> = <expr> is less or equal than <expr>
   <expr> > <expr> = <expr> is greater than <expr>
   <expr> >= <expr> = <expr> is greater or equal than <expr>
   <expr> == <expr> = <expr> is equal to <expr>


Cond:
   if (<expr>) <expr>
   otherwise <expr>

while:
   while <expr> doing <expr>

for:
   for(<init_expr>; <end_cond_expr>; )

for determinado:
   for(<delc_expr> : <iterable_expr>) <expr>
   los iterables son solo arreglos 